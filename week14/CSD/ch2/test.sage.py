

# This file was *autogenerated* from the file test.sage
from sage.all_cmdline import *   # import sage library

_sage_const_512 = Integer(512); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_10 = Integer(10); _sage_const_1024 = Integer(1024); _sage_const_256 = Integer(256); _sage_const_16 = Integer(16); _sage_const_90658561971338262202129460362336285748 = Integer(90658561971338262202129460362336285748); _sage_const_0 = Integer(0)
from Crypto.Util.number import *
import random

flag = b'CSDD{REDACTED}'

def genrsa():
  while True:
    try:
      p = getPrime(_sage_const_512 )
      q = getPrime(_sage_const_512 )
      n = p*q
      phi = (p-_sage_const_1 )*(q-_sage_const_1 )
      e = _sage_const_3 
      d = pow(e, -_sage_const_1 , phi)
      return e, d, n
    except:
      continue
  return None

e, d, n = genrsa()
c1 = pow(bytes_to_long(flag+b'\x44444444444444444'), e, n)
# print(pow((pow(256, 16)*bytes_to_long(flag) + 90658561971338262202129460362336285748),3,n))
c2 = pow(bytes_to_long(flag)+random.getrandbits(_sage_const_10 ), e, n)

print(c1)
# exit(1)
print(c2)
print(n)
print(e)
print("GENERATED")

R = Zmod(n)['X']; (X,) = R._first_ngens(1)

for r in range(_sage_const_1024 ):
  f1 = (pow(_sage_const_256 , _sage_const_16 )*X + _sage_const_90658561971338262202129460362336285748 )**_sage_const_3  - c1
  f2 = (X + r)**_sage_const_3  - c2

  # GCD is not implemented for rings over composite modulus in Sage
  # so we'll do it ourselves. Might fail in rare cases, but we
  # don't care.
  def my_gcd(a, b): 
    return a.monic() if b == _sage_const_0  else my_gcd(b, a % b)

  m = bytes_to_long(flag)
  m2 = -my_gcd(f1, f2).coefficients()[_sage_const_0 ] # coefficient 0 = -m
  print(m, m2)
  if(m==m2):
    print('real m:', m)
    print('recover m:', m2)
    break




